# 错误分类与重试策略文档

## 文档信息
- **文档名称**: 错误分类与重试策略文档
- **版本**: v1.0
- **创建日期**: 2025-09-25
- **最后更新**: 2025-09-25

## 1. 错误分类体系

### 1.1 错误分类层次结构
```
错误总分类
├── 系统级错误 (1000-1999)
│   ├── 网络错误 (1000-1099)
│   ├── 存储错误 (1100-1199)
│   ├── 内存错误 (1200-1299)
│   └── 配置错误 (1300-1399)
├── 业务级错误 (2000-2999)
│   ├── 输入验证错误 (2000-2099)
│   ├── 状态错误 (2100-2199)
│   ├── 权限错误 (2200-2299)
│   └── 逻辑错误 (2300-2399)
├── AI服务错误 (3000-3999)
│   ├── 调用错误 (3000-3099)
│   ├── 响应错误 (3100-3199)
│   ├── 解析错误 (3200-3299)
│   └── 限额错误 (3300-3399)
└── 用户界面错误 (4000-4999)
    ├── 渲染错误 (4000-4099)
    ├── 交互错误 (4100-4199)
    ├── 主题错误 (4200-4299)
    └── 响应错误 (4300-4399)
```

### 1.2 错误严重级别定义
```typescript
enum ErrorSeverity {
  CRITICAL = 'critical',    // 致命错误：系统无法继续运行
  HIGH = 'high',           // 高级错误：核心功能不可用
  MEDIUM = 'medium',       // 中级错误：部分功能受影响
  LOW = 'low',            // 低级错误：用户体验受影响
  INFO = 'info'           // 信息级：仅记录，不影响功能
}
```

## 2. 具体错误类型定义

### 2.1 系统级错误 (1000-1999)

#### 网络错误 (1000-1099)
```typescript
enum NetworkErrorCode {
  CONNECTION_FAILED = 1000,      // 连接失败
  CONNECTION_TIMEOUT = 1001,     // 连接超时
  DNS_RESOLUTION_FAILED = 1002,  // DNS解析失败
  SSL_HANDSHAKE_FAILED = 1003,   // SSL握手失败
  PROXY_ERROR = 1004,           // 代理错误
  NETWORK_UNREACHABLE = 1005,   // 网络不可达
  CONNECTION_RESET = 1006,      // 连接重置
  TOO_MANY_REQUESTS = 1007,     // 请求过多
  BANDWIDTH_EXCEEDED = 1008,    // 带宽超限
  FIREWALL_BLOCKED = 1009       // 防火墙阻止
}

interface NetworkError {
  code: NetworkErrorCode;
  severity: ErrorSeverity.HIGH;
  retryable: boolean;
  maxRetries: number;
  backoffStrategy: BackoffStrategy.EXPONENTIAL;
  timeout: number;
}
```

#### 存储错误 (1100-1199)
```typescript
enum StorageErrorCode {
  QUOTA_EXCEEDED = 1100,        // 存储空间超限
  ACCESS_DENIED = 1101,         // 访问被拒绝
  ITEM_NOT_FOUND = 1102,        // 项目未找到
  CORRUPTION_DETECTED = 1103,   // 数据损坏
  WRITE_FAILED = 1104,          // 写入失败
  READ_FAILED = 1105,           // 读取失败
  DELETE_FAILED = 1106,         // 删除失败
  LOCK_TIMEOUT = 1107,          // 锁定超时
  TRANSACTION_FAILED = 1108,    // 事务失败
  BACKUP_FAILED = 1109          // 备份失败
}

interface StorageError {
  code: StorageErrorCode;
  severity: ErrorSeverity.HIGH | ErrorSeverity.MEDIUM;
  retryable: boolean;
  affectedData?: string[];      // 受影响的数据项
  recoverySuggestion: string;   // 恢复建议
}
```

### 2.2 业务级错误 (2000-2999)

#### 输入验证错误 (2000-2099)
```typescript
enum ValidationErrorCode {
  INVALID_FORMAT = 2000,        // 格式无效
  FIELD_REQUIRED = 2001,        // 必填字段缺失
  VALUE_TOO_LONG = 2002,        // 值过长
  VALUE_TOO_SHORT = 2003,       // 值过短
  INVALID_RANGE = 2004,         // 值超出范围
  INVALID_ENUM = 2005,          // 枚举值无效
  PATTERN_MISMATCH = 2006,      // 模式不匹配
  DUPLICATE_VALUE = 2007,       // 重复值
  INVALID_REFERENCE = 2008,     // 引用无效
  SCHEMA_VIOLATION = 2009       // Schema违规
}

interface ValidationError {
  code: ValidationErrorCode;
  severity: ErrorSeverity.LOW;
  field: string;               // 错误字段
  value: any;                 // 错误值
  constraint: string;         // 约束条件
  retryable: false;
}
```

#### 状态错误 (2100-2199)
```typescript
enum StateErrorCode {
  INVALID_STATE_TRANSITION = 2100,  // 无效状态转换
  STATE_CONFLICT = 2101,            // 状态冲突
  CONCURRENT_MODIFICATION = 2102,   // 并发修改
  STATE_LOCKED = 2103,              // 状态被锁定
  RESOURCE_BUSY = 2104,             // 资源忙碌
  PRECONDITION_FAILED = 2105,       // 前置条件失败
  POSTCONDITION_FAILED = 2106,      // 后置条件失败
  DEADLOCK_DETECTED = 2107,         // 检测到死锁
  ROLLBACK_FAILED = 2108,           // 回滚失败
  CHECKPOINT_FAILED = 2109          // 检查点失败
}

interface StateError {
  code: StateErrorCode;
  severity: ErrorSeverity.MEDIUM;
  currentState: string;        // 当前状态
  attemptedState: string;      // 尝试转换的状态
  retryable: boolean;
  retryDelay?: number;        // 重试延迟
}
```

### 2.3 AI服务错误 (3000-3999)

#### AI调用错误 (3000-3099)
```typescript
enum AICallErrorCode {
  // 通用AI错误
  API_KEY_INVALID = 3000,       // API密钥无效
  API_KEY_EXPIRED = 3001,       // API密钥过期
  QUOTA_EXCEEDED = 3002,        // 配额超限
  RATE_LIMIT_EXCEEDED = 3003,   // 请求频率超限
  MODEL_NOT_AVAILABLE = 3004,   // 模型不可用
  SERVICE_UNAVAILABLE = 3005,   // 服务不可用
  INVALID_PARAMETERS = 3006,    // 参数无效
  CONTENT_FILTERED = 3007,      // 内容被过滤
  TOKEN_LIMIT_EXCEEDED = 3008,  // Token数量超限
  REGION_NOT_SUPPORTED = 3009,  // 地区不支持
  
  // DeepSeek特定错误 (3010-3019)
  DEEPSEEK_REASONING_FAILED = 3010,    // 推理模式失败
  DEEPSEEK_CACHE_ERROR = 3011,         // KV缓存错误
  DEEPSEEK_COMPATIBILITY_ERROR = 3012, // 兼容模式错误
  DEEPSEEK_TOKEN_CALC_ERROR = 3013,    // Token计算错误
  
  // Gemini特定错误 (3020-3029)
  GEMINI_SAFETY_FILTERED = 3020,       // 安全过滤器拦截
  GEMINI_MULTIMODAL_ERROR = 3021,      // 多模态处理错误
  GEMINI_LIVE_API_ERROR = 3022,        // Live API错误
  GEMINI_OAUTH_ERROR = 3023,           // OAuth认证错误
  GEMINI_CONTEXT_CACHE_ERROR = 3024,   // 上下文缓存错误
  
  // SiliconFlow特定错误 (3030-3039)
  SILICONFLOW_BALANCE_INSUFFICIENT = 3030, // 余额不足
  SILICONFLOW_BATCH_ERROR = 3031,          // 批处理错误
  SILICONFLOW_MODEL_SWITCH_ERROR = 3032,   // 模型切换错误
  SILICONFLOW_VOICE_ERROR = 3033,          // 语音服务错误
  SILICONFLOW_SERVICE_TYPE_ERROR = 3034    // 服务类型错误
}

interface AICallError {
  code: AICallErrorCode;
  severity: ErrorSeverity;
  provider: AIProvider;        // AI服务提供商
  model: string;              // 使用的模型
  requestId?: string;         // 请求ID
  retryable: boolean;
  retryAfter?: number;        // 重试等待时间(秒)
  
  // 服务商特定信息
  providerSpecific?: {
    // DeepSeek特定信息
    deepseek?: {
      cacheHitRate?: number;      // 缓存命中率
      reasoningTokens?: number;   // 推理使用的tokens
      compatibilityMode?: string; // 兼容模式
    };
    
    // Gemini特定信息
    gemini?: {
      safetyRatings?: SafetyRating[];  // 安全评级
      blockReason?: string;            // 拦截原因
      finishReason?: string;           // 结束原因
      candidateCount?: number;         // 候选回答数
    };
    
    // SiliconFlow特定信息
    siliconflow?: {
      currentBalance?: string;         // 当前余额
      availableModels?: string[];      // 可用模型
      serviceType?: string;            // 服务类型
      batchId?: string;                // 批处理ID
      costEstimate?: string;           // 成本估算
    };
  };
}

interface SafetyRating {
  category: string;
  probability: string;
  blocked: boolean;
}

enum AIProvider {
  OPENAI = 'openai',
  CLAUDE = 'claude', 
  DEEPSEEK = 'deepseek',
  GEMINI = 'gemini',
  SILICONFLOW = 'siliconflow'
}
```

#### AI响应解析错误 (3200-3299)
```typescript
enum AIParseErrorCode {
  INVALID_JSON = 3200,          // JSON格式无效
  MISSING_REQUIRED_FIELD = 3201, // 缺少必填字段
  FIELD_TYPE_MISMATCH = 3202,   // 字段类型不匹配
  FIELD_VALUE_INVALID = 3203,   // 字段值无效
  STRUCTURE_INVALID = 3204,     // 结构无效
  ENCODING_ERROR = 3205,        // 编码错误
  CONTENT_TRUNCATED = 3206,     // 内容被截断
  LANGUAGE_DETECTION_FAILED = 3207, // 语言检测失败
  SYNONYM_MAPPING_FAILED = 3208,    // 同义词映射失败
  FALLBACK_PARSE_FAILED = 3209      // 备用解析失败
}

interface AIParseError {
  code: AIParseErrorCode;
  severity: ErrorSeverity.MEDIUM;
  rawResponse: string;         // 原始响应
  parseStage: ParseStage;      // 解析阶段
  expectedFormat: string;      // 期望格式
  retryable: true;
  fallbackAvailable: boolean;  // 是否有备用方案
}
```

### 2.4 用户界面错误 (4000-4999)

#### 渲染错误 (4000-4099)
```typescript
enum RenderErrorCode {
  COMPONENT_MOUNT_FAILED = 4000,    // 组件挂载失败
  COMPONENT_UPDATE_FAILED = 4001,   // 组件更新失败
  TEMPLATE_COMPILE_FAILED = 4002,   // 模板编译失败
  STYLE_LOAD_FAILED = 4003,         // 样式加载失败
  RESOURCE_LOAD_FAILED = 4004,      // 资源加载失败
  ANIMATION_FAILED = 4005,          // 动画失败
  LAYOUT_CALCULATION_FAILED = 4006, // 布局计算失败
  EVENT_BINDING_FAILED = 4007,      // 事件绑定失败
  MEMORY_LEAK_DETECTED = 4008,      // 检测到内存泄漏
  PERFORMANCE_DEGRADED = 4009       // 性能下降
}

interface RenderError {
  code: RenderErrorCode;
  severity: ErrorSeverity.MEDIUM;
  component: string;           // 出错组件
  element?: string;           // DOM元素
  retryable: boolean;
  userVisible: boolean;       // 用户是否可见
}
```

## 3. 重试策略框架

### 3.1 重试策略类型
```typescript
enum RetryStrategy {
  NONE = 'none',               // 不重试
  IMMEDIATE = 'immediate',     // 立即重试
  FIXED_DELAY = 'fixed_delay', // 固定延迟
  EXPONENTIAL = 'exponential', // 指数退避
  LINEAR = 'linear',           // 线性增长
  CUSTOM = 'custom'            // 自定义策略
}
```

### 3.2 重试配置定义
```typescript
interface RetryConfig {
  strategy: RetryStrategy;     // 重试策略
  maxAttempts: number;         // 最大重试次数
  baseDelay: number;           // 基础延迟时间(ms)
  maxDelay: number;            // 最大延迟时间(ms)
  multiplier?: number;         // 倍数因子（指数退避）
  jitter?: boolean;            // 是否添加随机抖动
  retryCondition?: (error: BaseError) => boolean; // 重试条件
  fallbackHandler?: FallbackHandler; // 降级处理器
}

interface FallbackHandler {
  canHandle: (error: BaseError) => boolean;
  handle: (error: BaseError, context: any) => Promise<any>;
  priority: number;
}
```

### 3.3 具体重试策略实现

#### 指数退避策略
```typescript
class ExponentialBackoffStrategy implements RetryStrategy {
  private config: RetryConfig;
  
  constructor(config: RetryConfig) {
    this.config = config;
  }
  
  calculateDelay(attempt: number): number {
    let delay = this.config.baseDelay * Math.pow(this.config.multiplier || 2, attempt - 1);
    
    // 限制最大延迟
    delay = Math.min(delay, this.config.maxDelay);
    
    // 添加随机抖动
    if (this.config.jitter) {
      delay += Math.random() * delay * 0.1;
    }
    
    return delay;
  }
  
  shouldRetry(attempt: number, error: BaseError): boolean {
    if (attempt >= this.config.maxAttempts) {
      return false;
    }
    
    if (this.config.retryCondition) {
      return this.config.retryCondition(error);
    }
    
    return error.retryable;
  }
}
```

#### 线性退避策略
```typescript
class LinearBackoffStrategy implements RetryStrategy {
  calculateDelay(attempt: number): number {
    return this.config.baseDelay * attempt;
  }
}
```

#### 自定义策略
```typescript
interface CustomRetryStrategy {
  name: string;
  calculate: (attempt: number, error: BaseError, history: RetryAttempt[]) => number;
  shouldStop: (attempt: number, error: BaseError, history: RetryAttempt[]) => boolean;
}

interface RetryAttempt {
  attempt: number;
  timestamp: number;
  error: BaseError;
  delay: number;
  success: boolean;
}
```

## 4. 错误处理流程

### 4.1 四步错误处理流程
```
1. 约束检查 (Constraint Check)
   ↓
2. 数据验证 (Validation)  
   ↓
3. 备用方案 (Fallback)
   ↓
4. 重试机制 (Retry)
```

### 4.2 错误处理流程图
```typescript
interface ErrorHandlingFlow {
  // 第一步：约束检查
  constraintCheck(input: any): ConstraintCheckResult;
  
  // 第二步：数据验证
  validate(data: any, schema: any): ValidationResult;
  
  // 第三步：备用方案
  applyFallback(error: BaseError, context: any): FallbackResult;
  
  // 第四步：重试机制
  executeWithRetry(operation: Operation, config: RetryConfig): Promise<any>;
}

interface ConstraintCheckResult {
  passed: boolean;
  violations: ConstraintViolation[];
}

interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  sanitized?: any;
}

interface FallbackResult {
  success: boolean;
  data?: any;
  partial: boolean;
}
```

### 4.3 错误恢复策略
```typescript
enum RecoveryStrategy {
  RETRY = 'retry',             // 重试
  FALLBACK = 'fallback',       // 降级
  SKIP = 'skip',               // 跳过
  ABORT = 'abort',             // 中止
  COMPENSATE = 'compensate',   // 补偿
  CIRCUIT_BREAK = 'circuit_break' // 熔断
}

interface RecoveryPlan {
  strategy: RecoveryStrategy;
  actions: RecoveryAction[];
  timeoutMs: number;
  fallbackChain?: FallbackHandler[];
}

interface RecoveryAction {
  type: 'cleanup' | 'rollback' | 'notify' | 'log' | 'metric';
  handler: (error: BaseError, context: any) => Promise<void>;
  critical: boolean;
}
```

## 5. 错误监控与告警

### 5.1 错误指标统计
```typescript
interface ErrorMetrics {
  // 基本统计
  totalErrors: number;         // 总错误数
  errorsByCode: Record<number, number>; // 按错误码统计
  errorsBySeverity: Record<ErrorSeverity, number>; // 按严重级别统计
  errorsByModule: Record<string, number>; // 按模块统计
  
  // 时间相关
  errorRate: number;           // 错误率
  recentErrors: ErrorOccurrence[]; // 最近错误
  errorTrends: TrendData[];    // 错误趋势
  
  // 重试相关
  retryRate: number;           // 重试率
  avgRetryAttempts: number;    // 平均重试次数
  retrySuccessRate: number;    // 重试成功率
  
  // 恢复相关
  recoveryTime: TimeMetrics;   // 恢复时间指标
  fallbackUsage: number;       // 降级使用次数
}

interface ErrorOccurrence {
  timestamp: number;
  error: BaseError;
  context: ErrorContext;
  resolved: boolean;
  resolutionTime?: number;
}
```

### 5.2 错误告警配置
```typescript
interface ErrorAlert {
  id: string;
  name: string;
  condition: AlertCondition;
  severity: AlertSeverity;
  channels: NotificationChannel[];
  throttle: ThrottleConfig;
}

interface AlertCondition {
  errorCodes?: number[];       // 特定错误码
  errorRate?: number;          // 错误率阈值
  frequency?: number;          // 频率阈值
  timeWindow: number;          // 时间窗口(ms)
  customCondition?: (metrics: ErrorMetrics) => boolean;
}

enum AlertSeverity {
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error',
  CRITICAL = 'critical'
}

interface NotificationChannel {
  type: 'email' | 'sms' | 'webhook' | 'slack';
  config: any;
  enabled: boolean;
}
```

### 5.3 错误报告生成
```typescript
interface ErrorReport {
  timeRange: TimeRange;
  summary: ErrorSummary;
  details: ErrorDetail[];
  recommendations: Recommendation[];
  trends: TrendAnalysis;
}

interface ErrorSummary {
  totalOccurrences: number;
  uniqueErrors: number;
  criticalErrors: number;
  resolvedErrors: number;
  avgResolutionTime: number;
  mostFrequentErrors: ErrorFrequency[];
}

interface Recommendation {
  type: 'fix' | 'prevention' | 'monitoring' | 'optimization';
  priority: 'high' | 'medium' | 'low';
  description: string;
  actionItems: string[];
  estimatedImpact: string;
}
```

## 6. 熔断器模式

### 6.1 熔断器状态
```typescript
enum CircuitBreakerState {
  CLOSED = 'closed',           // 正常状态
  OPEN = 'open',              // 熔断状态
  HALF_OPEN = 'half_open'     // 半开状态
}

interface CircuitBreaker {
  state: CircuitBreakerState;
  failureCount: number;        // 失败计数
  successCount: number;        // 成功计数
  lastFailureTime?: number;    // 最后失败时间
  config: CircuitBreakerConfig;
}

interface CircuitBreakerConfig {
  failureThreshold: number;    // 失败阈值
  timeout: number;            // 超时时间(ms)
  monitoringPeriod: number;   // 监控周期(ms)
  resetTimeout: number;       // 重置超时(ms)
  halfOpenMaxCalls: number;   // 半开状态最大调用数
}
```

### 6.2 熔断器实现
```typescript
class CircuitBreakerImpl {
  private state: CircuitBreakerState = CircuitBreakerState.CLOSED;
  private failureCount: number = 0;
  private successCount: number = 0;
  private lastFailureTime?: number;
  
  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === CircuitBreakerState.OPEN) {
      if (this.shouldAttemptReset()) {
        this.state = CircuitBreakerState.HALF_OPEN;
        this.successCount = 0;
      } else {
        throw new CircuitBreakerOpenError();
      }
    }
    
    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess(): void {
    this.failureCount = 0;
    if (this.state === CircuitBreakerState.HALF_OPEN) {
      this.successCount++;
      if (this.successCount >= this.config.halfOpenMaxCalls) {
        this.state = CircuitBreakerState.CLOSED;
      }
    }
  }
  
  private onFailure(): void {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.config.failureThreshold) {
      this.state = CircuitBreakerState.OPEN;
    }
  }
}
```

## 7. 用户友好的错误提示

### 7.1 错误消息本地化（支持三个主要AI服务商）
```typescript
interface ErrorMessage {
  code: number;
  level: 'user' | 'developer' | 'system';
  title: LocalizedString;
  description: LocalizedString;
  solution?: LocalizedString;
  moreInfo?: string;          // 详细信息链接
  provider?: AIProvider;      // 特定服务商
}

interface LocalizedString {
  zh: string;                 // 中文
  en: string;                 // 英文
  [key: string]: string;      // 其他语言
}

// 错误消息映射 - 支持三个主要AI服务商
const ErrorMessages: Record<number, ErrorMessage> = {
  // 通用AI服务错误
  3000: {
    code: 3000,
    level: 'user',
    title: {
      zh: 'AI服务密钥无效',
      en: 'Invalid AI Service Key'
    },
    description: {
      zh: '您配置的AI服务密钥已失效，请检查并更新密钥配置。',
      en: 'Your AI service key is invalid. Please check and update your key configuration.'
    },
    solution: {
      zh: '请前往设置页面重新配置有效的API密钥。',
      en: 'Please go to settings page to reconfigure a valid API key.'
    },
    moreInfo: '/help/ai-service-setup'
  },
  
  // DeepSeek特定错误
  3010: {
    code: 3010,
    level: 'user',
    provider: AIProvider.DEEPSEEK,
    title: {
      zh: 'DeepSeek推理模式失败',
      en: 'DeepSeek Reasoning Failed'
    },
    description: {
      zh: 'DeepSeek推理模型无法处理当前请求，将自动切换到标准聊天模式。',
      en: 'DeepSeek reasoning model failed to process the request. Switching to standard chat mode.'
    },
    solution: {
      zh: '系统已自动切换模式，您可以继续游戏。如需重新启用推理模式，请在设置中调整。',
      en: 'System has automatically switched modes. You can continue playing. To re-enable reasoning mode, adjust settings.'
    }
  },
  
  3011: {
    code: 3011,
    level: 'developer',
    provider: AIProvider.DEEPSEEK,
    title: {
      zh: 'DeepSeek KV缓存错误',
      en: 'DeepSeek KV Cache Error'
    },
    description: {
      zh: 'KV缓存机制出现异常，可能影响性能但不影响功能。',
      en: 'KV cache mechanism encountered an error. May affect performance but not functionality.'
    }
  },
  
  // Gemini特定错误
  3020: {
    code: 3020,
    level: 'user',
    provider: AIProvider.GEMINI,
    title: {
      zh: 'Gemini安全过滤',
      en: 'Gemini Safety Filter'
    },
    description: {
      zh: '您的请求被Gemini安全过滤器拦截。请调整输入内容或降低安全设置。',
      en: 'Your request was blocked by Gemini safety filters. Please adjust input content or lower safety settings.'
    },
    solution: {
      zh: '请修改输入内容或在设置中调整Gemini安全等级。',
      en: 'Please modify input content or adjust Gemini safety level in settings.'
    }
  },
  
  3022: {
    code: 3022,
    level: 'user',
    provider: AIProvider.GEMINI,
    title: {
      zh: 'Gemini Live API错误',
      en: 'Gemini Live API Error'
    },
    description: {
      zh: 'Gemini实时API服务不可用，已切换到普通模式。',
      en: 'Gemini Live API service is unavailable. Switched to regular mode.'
    }
  },
  
  // SiliconFlow特定错误
  3030: {
    code: 3030,
    level: 'user',
    provider: AIProvider.SILICONFLOW,
    title: {
      zh: 'SiliconFlow余额不足',
      en: 'SiliconFlow Insufficient Balance'
    },
    description: {
      zh: '您的SiliconFlow账户余额不足以完成此请求。',
      en: 'Your SiliconFlow account balance is insufficient to complete this request.'
    },
    solution: {
      zh: '请前往SiliconFlow官网充值或切换到其他AI服务。',
      en: 'Please recharge at SiliconFlow official website or switch to other AI service.'
    },
    moreInfo: 'https://cloud.siliconflow.cn/account/balance'
  },
  
  3032: {
    code: 3032,
    level: 'user',
    provider: AIProvider.SILICONFLOW,
    title: {
      zh: 'SiliconFlow模型切换失败',
      en: 'SiliconFlow Model Switch Failed'
    },
    description: {
      zh: '无法切换到指定模型，继续使用当前模型。',
      en: 'Failed to switch to specified model. Continue using current model.'
    }
  }
};
```

### 7.2 错误处理用户界面
```typescript
interface ErrorUI {
  // 显示错误
  showError(error: BaseError, context?: any): void;
  
  // 显示重试选项
  showRetryOptions(error: BaseError, retryCallback: () => void): void;
  
  // 显示降级提示
  showFallbackNotification(message: string, action?: () => void): void;
  
  // 错误恢复引导
  showRecoveryGuide(error: BaseError): void;
}

interface ErrorUIConfig {
  // 显示设置
  showStackTrace: boolean;     // 是否显示堆栈跟踪
  autoHide: boolean;          // 是否自动隐藏
  autoHideDelay: number;      // 自动隐藏延迟
  
  // 交互设置
  allowRetry: boolean;        // 允许手动重试
  allowReporting: boolean;    // 允许错误报告
  showDetailsToggle: boolean; // 显示详情切换
  
  // 主题设置
  theme: 'light' | 'dark' | 'auto';
  animation: boolean;         // 启用动画
}
```

## 8. AI服务集成错误预防与最佳实践

### 8.1 防御性编程
```typescript
interface DefensiveProgramming {
  // 输入验证
  validateInput(input: any, schema: ValidationSchema): ValidationResult;
  
  // 边界检查
  checkBounds(value: number, min: number, max: number): boolean;
  
  // 空值检查
  checkNull<T>(value: T | null | undefined): value is T;
  
  // 类型检查
  checkType<T>(value: any, type: string): value is T;
  
  // 断言
  assert(condition: boolean, message: string): void;
}

// 使用示例
function processUserInput(input: string): ProcessedInput {
  // 输入验证
  const validation = validateInput(input, INPUT_SCHEMA);
  if (!validation.valid) {
    throw new ValidationError(2000, 'Input validation failed', validation.errors);
  }
  
  // 边界检查
  if (!checkBounds(input.length, 1, 1000)) {
    throw new ValidationError(2002, 'Input length out of bounds');
  }
  
  // 空值检查
  if (!checkNull(input)) {
    throw new ValidationError(2001, 'Input is required');
  }
  
  return { processed: input.trim() };
}
```

### 8.2 AI服务商特定错误预防检查清单
```typescript
const AIServiceErrorPreventionChecklist = {
  // 通用检查项
  common: {
    design: [
      '定义清晰的错误边界',
      '设计合理的降级方案',
      '规划错误恢复流程',
      '考虑并发和竞态条件'
    ],
    development: [
      '实现输入验证',
      '添加异常处理',
      '编写单元测试',
      '进行代码评审'
    ],
    testing: [
      '错误场景测试',
      '边界条件测试',
      '压力测试',
      '故障注入测试'
    ],
    deployment: [
      '配置监控告警',
      '准备应急预案',
      '文档完整性检查',
      '回滚方案验证'
    ]
  },
  
  // DeepSeek特定检查
  deepseek: {
    apiKey: '确俚API密钥来源于DeepSeek平台',
    reasoning: '测试推理模式的稳定性和降级机制',
    cache: '验证KV缓存效果和成本优化',
    compatibility: '测试OpenAI/Anthropic兼容模式',
    tokenCalculation: '验证token计算的准确性'
  },
  
  // Gemini特定检查
  gemini: {
    safety: '测试安全过滤器在不同内容下的表现',
    multimodal: '验证多模态输入的处理能力',
    liveApi: '测试Live API的连接稳定性',
    oauth: '验证OAuth 2.0认证流程',
    quotaManagement: '监控API配额使用情况'
  },
  
  // SiliconFlow特定检查
  siliconflow: {
    balance: '监控余额变化和预警机制',
    modelAvailability: '检查模型可用性和切换策略',
    batchProcessing: '测试批处理功能的稳定性',
    voiceServices: '验证语音服务的质量和可用性',
    serviceTypes: '测试不同服务类型的切换'
  }
};
```

### 8.3 AI服务集成代码质量门禁
```typescript
interface AIServiceQualityGate extends QualityGate {
  // 通用静态分析
  staticAnalysis: {
    codeComplexity: number;      // 代码复杂度阈值
    duplicateCode: number;       // 重复代码比例
    codeSmells: number;          // 代码异味数量
    securityVulnerabilities: number; // 安全漏洞数量
  };
  
  // 测试覆盖率
  testCoverage: {
    line: number;               // 行覆盖率
    branch: number;             // 分支覆盖率
    function: number;           // 函数覆盖率
    statement: number;          // 语句覆盖率
    
    // AI服务特定覆盖
    aiServiceCoverage: {
      deepseekTests: number;     // DeepSeek测试覆盖率
      geminiTests: number;       // Gemini测试覆盖率
      siliconflowTests: number;  // SiliconFlow测试覆盖率
      errorScenarios: number;    // 错误场景覆盖率
      fallbackMechanisms: number; // 降级机制覆盖率
    };
  };
  
  // AI服务错误处理
  aiErrorHandling: {
    uncaughtExceptions: number;  // 未捕获异常数量
    errorPathsCovered: number;   // 错误路径覆盖率
    recoveryMechanisms: number;  // 恢复机制数量
    monitoringCoverage: number;  // 监控覆盖率
    
    // AI服务特定错误处理
    serviceSpecificHandling: {
      deepseekErrorHandling: number;     // DeepSeek错误处理覆盖
      geminiSafetyHandling: number;      // Gemini安全过滤处理
      siliconflowBalanceHandling: number; // SiliconFlow余额处理
      providerFallback: number;           // 跨服务商降级覆盖
      retryStrategies: number;            // 重试策略覆盖
    };
  };
  
  // AI服务集成质量指标
  integrationQuality: {
    apiCompatibility: number;    // API兼容性分数
    responseStability: number;   // 响应稳定性分数
    errorRecoveryRate: number;   // 错误恢复成功率
    performanceScore: number;    // 性能评分
    costEfficiency: number;      // 成本效率评分
  };
}

// AI服务商特定质量检查
interface ServiceSpecificQualityChecks {
  deepseek: {
    reasoningModeStability: boolean;   // 推理模式稳定性
    cacheEfficiency: number;           // 缓存效率
    compatibilityModeTest: boolean;    // 兼容模式测试
    tokenAccuracy: number;             // Token计算准确性
  };
  
  gemini: {
    safetyFilterTest: boolean;         // 安全过滤器测试
    multimodalSupport: boolean;        // 多模态支持测试
    liveApiStability: boolean;         // Live API稳定性
    oauthFlowTest: boolean;            // OAuth流程测试
  };
  
  siliconflow: {
    balanceMonitoring: boolean;        // 余额监控测试
    modelSwitching: boolean;           // 模型切换测试
    batchProcessing: boolean;          // 批处理测试
    voiceServiceQuality: number;       // 语音服务质量
    serviceTypeSupport: boolean;       // 多服务类型支持
  };
}
```