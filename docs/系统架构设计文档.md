# AI文字游戏渲染器 - 系统架构设计文档

## 1. 整体系统架构图

```
┌─────────────────────────────────────────────────────────────────────┐
│                        AI文字游戏渲染器                              │
├─────────────────────────────────────────────────────────────────────┤
│  用户交互层 (User Interaction Layer)                                 │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐         │
│  │  输入处理模块   │ │  界面控制模块   │ │  导航控制模块   │         │
│  │  - 文本输入     │ │  - 模态框管理   │ │  - 页面路由     │         │
│  │  - 选项点击     │ │  - 通知系统     │ │  - 历史导航     │         │
│  │  - 快捷键       │ │  - 加载状态     │ │  - 面板切换     │         │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘         │
├─────────────────────────────────────────────────────────────────────┤
│  界面渲染层 (UI Rendering Layer)                                     │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐         │
│  │ 主游戏界面模块  │ │ 扩展卡片系统    │ │  布局管理模块   │         │
│  │  - 场景渲染器   │ │  - 卡片工厂     │ │  - 响应式布局   │         │
│  │  - 旁白渲染器   │ │  - 卡片渲染器   │ │  - 抽屉管理     │         │
│  │  - 选项渲染器   │ │  - 数据绑定器   │ │  - 主题切换     │         │
│  │  - 状态栏渲染   │ │  - 布局管理器   │ │  - 动画引擎     │         │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘         │
├─────────────────────────────────────────────────────────────────────┤
│  业务逻辑层 (Business Logic Layer)                                   │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐         │
│  │  核心引擎模块   │ │  配置管理模块   │ │   事件总线      │         │
│  │  - 游戏状态管理 │ │  - 世界观配置   │ │  - 事件发布     │         │
│  │  - 数据处理引擎 │ │  - 状态栏配置   │ │  - 订阅管理     │         │
│  │  - 流程控制器   │ │  - AI配置管理   │ │  - 模块通信     │         │
│  └─────────────────┘ │  - 预设管理     │ └─────────────────┘         │
│                      └─────────────────┘                             │
├─────────────────────────────────────────────────────────────────────┤
│  服务集成层 (Service Integration Layer)                              │
│  ┌─────────────────────────────────────────────────────────────────┐ │
│  │                    AI服务模块                                   │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │
│  │  │ 连接管理器  │ │ 请求处理器  │ │ 错误处理器  │ │ 解析引擎    │ │ │
│  │  │ - 多服务适配│ │ - 请求构建  │ │ - 错误分类  │ │ - JSON提取  │ │ │
│  │  │ - 连接池    │ │ - 请求发送  │ │ - 重试策略  │ │ - 格式修复  │ │ │
│  │  │ - 限流控制  │ │ - 响应接收  │ │ - 降级处理  │ │ - 结构验证  │ │ │
│  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────┤
│  数据存储层 (Data Storage Layer)                                     │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐         │
│  │  本地存储模块   │ │  导入导出模块   │ │  缓存管理模块   │         │
│  │  - 浏览器存储   │ │  - 文件导出器   │ │  - 内存缓存     │         │
│  │  - 数据序列化   │ │  - 文件导入器   │ │  - 缓存策略     │         │
│  │  - 配额管理     │ │  - 格式转换     │ │  - 自动清理     │         │
│  │  - 数据压缩     │ │  - 版本兼容     │ │  - 数据备份     │         │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘         │
├─────────────────────────────────────────────────────────────────────┤
│  工具支撑层 (Utility Support Layer)                                  │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐         │
│  │  性能监控模块   │ │  错误监控模块   │ │  调试工具模块   │         │
│  │  - 渲染性能监控 │ │  - 全局错误捕获 │ │  - 开发者面板   │         │
│  │  - API统计      │ │  - 错误统计分析 │ │  - 数据检查器   │         │
│  │  - 内存监控     │ │  - 行为追踪     │ │  - 日志管理     │         │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘         │
└─────────────────────────────────────────────────────────────────────┘
              ↕                    ↕                    ↕
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│   DeepSeek API  │  │   Gemini API    │  │ SiliconFlow API │
│   - deepseek-chat│  │ - gemini-2.5-flash│ - Qwen2.5-7B    │
│   - deepseek-    │  │ - Live API      │  - DeepSeek-V2.5 │
│     reasoner    │  │ - Multimodal    │  - Batch Process │
│   - KV Cache    │  │ - Safety Filter │  - Voice Service │
└─────────────────┘  └─────────────────┘  └─────────────────┘
```

## 2. 技术架构选型说明

### 2.1 前端技术栈

#### 2.1.1 核心框架
- **React 18+**：主UI框架，支持并发特性和Suspense
- **TypeScript 5+**：提供类型安全和更好的开发体验
- **Vite 5+**：现代构建工具，快速的开发和构建体验

#### 2.1.2 状态管理
- **Zustand**：轻量级状态管理，替代Redux的简单方案
- **React Query (TanStack Query)**：服务端状态管理和缓存
- **Jotai**：原子化状态管理，处理复杂的局部状态

#### 2.1.3 UI组件库
- **Headless UI + Tailwind CSS**：无样式组件库+原子化CSS
- **Framer Motion**：动画库，提供流畅的界面动画
- **React Hook Form**：表单管理库

#### 2.1.4 工具库
- **Lodash-ES**：工具函数库（按需引入）
- **Date-fns**：日期处理库
- **Zod**：TypeScript优先的数据验证库

### 2.2 技术选型理由

#### 2.2.1 为什么选择React
- **生态丰富**：大量现成的组件库和工具
- **社区活跃**：问题解决方案多，学习资料丰富
- **性能优秀**：虚拟DOM和并发特性保证渲染性能
- **TypeScript支持好**：类型定义完善
- **AI集成友好**：适合处理复杂的AI响应数据和状态管理

#### 2.2.2 为什么选择Zustand而非Redux
- **学习成本低**：API简单，易于上手
- **代码量少**：减少样板代码
- **性能优秀**：自动优化重渲染
- **TypeScript友好**：天然支持类型推导

#### 2.2.3 为什么选择Tailwind CSS
- **开发效率高**：原子化类名，快速样式编写
- **体积可控**：按需生成，最终包体积小
- **可定制性强**：配置灵活，易于主题切换
- **响应式支持好**：内置响应式断点

## 3. 部署架构设计

### 3.1 静态站点部署

```
┌─────────────────────────────────────────────────────────────┐
│                     CDN/Edge Network                        │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   Vercel    │ │   Netlify   │ │   Cloudflare│           │
│  │    Edge     │ │    Edge     │ │    Pages    │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                    Static File Hosting                      │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Built Application                          │ │
│  │  - HTML/CSS/JS Files                                   │ │
│  │  - Static Assets (Images, Fonts)                      │ │
│  │  - Service Worker                                      │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                    User's Browser                           │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │               Application Runtime                       │ │
│  │  - React Application                                   │ │
│  │  - Local Storage (IndexedDB)                          │ │
│  │  - Service Worker Cache                               │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                      │           │           │
                      ▼           ▼           ▼
                ┌─────────┐ ┌─────────┐ ┌─────────┐
                │OpenAI   │ │Claude   │ │Other AI │
                │API      │ │API      │ │APIs     │
                └─────────┘ └─────────┘ └─────────┘
```

### 3.2 部署策略

#### 3.2.1 构建优化
- **代码分割**：按路由和功能模块进行代码分割
- **Tree Shaking**：移除未使用的代码
- **资源压缩**：Gzip/Brotli压缩
- **缓存策略**：文件名哈希，长期缓存

#### 3.2.2 CDN部署
- **多地域节点**：全球CDN节点分发
- **智能路由**：就近访问，降低延迟
- **自动部署**：Git提交触发自动构建部署

#### 3.2.3 HTTPS和安全
- **强制HTTPS**：所有连接必须HTTPS
- **CSP策略**：内容安全策略防止XSS
- **CORS配置**：合理的跨域资源共享配置

## 4. 模块划分和组织结构

### 4.1 项目目录结构

```
src/
├── components/          # 通用UI组件
│   ├── ui/             # 基础UI组件
│   └── game/           # 游戏特定组件
├── modules/            # 业务模块
│   ├── core/           # 核心引擎模块
│   │   ├── gameState/  # 游戏状态管理
│   │   ├── dataProcessor/ # 数据处理
│   │   └── eventBus/   # 事件总线
│   ├── ai/             # AI服务模块
│   │   ├── adapters/   # 服务适配器
│   │   │   ├── deepseek/   # DeepSeek适配器
│   │   │   ├── gemini/     # Gemini适配器
│   │   │   └── siliconflow/ # SiliconFlow适配器
│   │   ├── connection/ # 连接管理
│   │   ├── request/    # 请求处理
│   │   ├── error/      # 错误处理
│   │   └── parse/      # 解析引擎
│   ├── ui/             # 界面渲染模块
│   │   ├── game/       # 主游戏界面
│   │   ├── cards/      # 扩展卡片
│   │   ├── layout/     # 布局管理
│   │   └── animation/  # 动画引擎
│   ├── config/         # 配置管理模块
│   │   ├── world/      # 世界观配置
│   │   ├── status/     # 状态栏配置
│   │   ├── ai/         # AI配置
│   │   └── preset/     # 预设管理
│   ├── storage/        # 数据存储模块
│   │   ├── local/      # 本地存储
│   │   ├── import/     # 导入导出
│   │   └── cache/      # 缓存管理
│   ├── interaction/    # 用户交互模块
│   │   ├── input/      # 输入处理
│   │   ├── ui/         # 界面控制
│   │   └── navigation/ # 导航控制
│   └── utils/          # 工具辅助模块
│       ├── performance/ # 性能监控
│       ├── error/      # 错误监控
│       ├── debug/      # 调试工具
│       └── lib/        # 工具库
├── hooks/              # React Hooks
├── stores/             # Zustand状态库
├── types/              # TypeScript类型定义
├── constants/          # 常量定义
├── assets/             # 静态资源
└── app/                # 应用入口和路由
```

### 4.2 模块接口设计

#### 4.2.1 模块接口规范
```typescript
// 标准模块接口
interface ModuleInterface {
  name: string;
  version: string;
  dependencies: string[];
  initialize(): Promise<void>;
  destroy(): Promise<void>;
  getAPI(): Record<string, Function>;
}

// 示例：AI服务模块接口（支持三个主要服务商）
interface AIServiceModule extends ModuleInterface {
  connect(config: AIConfig): Promise<Connection>;
  sendRequest(request: GameRequest): Promise<GameResponse>;
  disconnect(): Promise<void>;
  getStatus(): ConnectionStatus;
  
  // 服务商特定方法
  switchProvider(provider: 'deepseek' | 'gemini' | 'siliconflow'): Promise<void>;
  getProviderCapabilities(): ProviderCapabilities;
  
  // DeepSeek特定功能
  enableReasoningMode?(enabled: boolean): void;
  getCacheHitRate?(): number;
  
  // Gemini特定功能
  setSafetyLevel?(level: SafetyLevel): void;
  enableMultimodal?(enabled: boolean): void;
  
  // SiliconFlow特定功能
  getBalance?(): Promise<number>;
  enableBatchProcessing?(enabled: boolean): void;
}
```

#### 4.2.2 模块通信机制
```typescript
// 事件总线通信
interface EventBus {
  emit<T>(event: string, data: T): void;
  on<T>(event: string, handler: (data: T) => void): void;
  off(event: string, handler: Function): void;
  once<T>(event: string, handler: (data: T) => void): void;
}

// 模块间依赖注入
interface ModuleContainer {
  register<T>(name: string, module: T): void;
  resolve<T>(name: string): T;
  has(name: string): boolean;
}
```

## 5. 数据流向和处理流程

### 5.1 游戏核心数据流

```
[用户输入] → [输入处理模块] → [游戏状态管理]
                                     ↓
[界面渲染] ← [数据处理引擎] ← [Prompt组装器]
     ↑                            ↓
[状态更新] ← [响应解析器] ← [AI服务模块] → [外部AI API]
     ↓              ↑
[本地存储] → [历史记录管理器]
```

### 5.2 详细处理流程

#### 5.2.1 用户操作处理流程
```typescript
// 1. 用户输入处理
User Input → InputProcessor.process() → {
  type: 'user_input' | 'option_click',
  content: string,
  timestamp: number
}

// 2. 游戏状态更新
GameStateManager.updateState() → {
  currentRound: number,
  playerInput: string,
  gameHistory: GameRound[]
}

// 3. Prompt组装
PromptBuilder.buildPrompt() → {
  worldConfig: WorldConfig,
  statusConfig: StatusConfig,
  gameHistory: string,
  currentInput: string,
  outputRequirements: string
}

// 4. AI请求发送
AIService.sendRequest() → Promise<AIResponse>

// 5. 响应解析
ResponseParser.parse() → {
  scene: string,
  narration: string,
  options: GameOption[],
  status: GameStatus,
  custom: CustomData
}

// 6. 界面更新
UIRenderer.render() → DOM Updates

// 7. 数据存储
StorageManager.save() → LocalStorage/IndexedDB
```

#### 5.2.2 配置管理流程
```typescript
// 配置加载流程
ConfigLoader.load() → {
  world: WorldConfig,
  status: StatusConfig,
  ai: AIConfig,
  extensions: ExtensionConfig[]
}

// 配置验证流程
ConfigValidator.validate() → {
  isValid: boolean,
  errors: ValidationError[]
}

// 配置应用流程
ConfigApplier.apply() → {
  gameEngine: EngineConfig,
  uiRenderer: RenderConfig,
  aiService: ServiceConfig
}
```

#### 5.2.3 错误处理流程
```typescript
// 错误捕获和分类
try {
  // 业务逻辑
} catch (error) {
  ErrorHandler.handle(error) → {
    type: 'network' | 'parse' | 'validation' | 'system',
    severity: 'low' | 'medium' | 'high' | 'critical',
    recovery: RecoveryStrategy,
    userMessage: string
  }
}

// 自动恢复机制
RecoveryManager.recover() → {
  strategy: 'retry' | 'fallback' | 'reset' | 'manual',
  success: boolean,
  newState: GameState
}
```

## 6. 安全性和性能考虑

### 6.1 安全性措施

#### 6.1.1 数据安全
- **API密钥保护**：仅存储在浏览器本地，不传输到服务器
- **数据加密**：敏感配置数据使用加密存储
- **输入验证**：所有用户输入进行严格验证和清理
- **XSS防护**：内容安全策略和输出转义

#### 6.1.2 隐私保护
- **本地优先**：游戏数据仅存储在用户本地
- **最小化传输**：只传输必要的游戏内容给AI
- **用户控制**：用户完全控制数据的导出和删除

### 6.2 性能优化（针对三个主要AI服务商）

#### 6.2.1 前端性能
- **代码分割**：按需加载，减少初始包大小
- **虚拟化渲染**：长列表使用虚拟滚动
- **防抖节流**：用户输入和API请求的频率控制
- **内存管理**：及时清理不需要的数据和事件监听器
- **AI适配器懒加载**：按需加载不同的AI服务适配器

#### 6.2.2 渲染性能
- **React.memo**：防止不必要的组件重渲染
- **useMemo/useCallback**：缓存计算结果和函数
- **批量更新**：合并状态更新，减少渲染次数
- **CSS优化**：使用GPU加速的CSS属性

#### 6.2.3 AI服务性能优化
- **DeepSeek优化**：
  - 利用KV缓存减少重复计算
  - 智能选择推理模式vs标准模式
  - Token计算本地化避免额外API调用
- **Gemini优化**：
  - 上下文缓存优化长对话
  - 多模态内容预加载
  - 安全过滤器结果缓存
- **SiliconFlow优化**：
  - 批处理合并多个请求
  - 智能模型切换避免高峰拥堵
  - 余额预加载避免请求失败

#### 6.2.4 网络性能
- **请求缓存**：合理的HTTP缓存策略
- **连接复用**：Keep-Alive连接
- **压缩传输**：请求和响应数据压缩
- **超时控制**：合理的请求超时设置
- **重试策略**：指数退避重试机制
- **熔断器**：服务不可用时的熔断保护

## 7. 监控和维护

### 7.1 性能监控
- **Web Vitals监控**：LCP、FID、CLS等核心性能指标
- **用户体验监控**：页面加载时间、交互延迟
- **资源使用监控**：内存、CPU使用情况
- **AI服务性能监控**：
  - DeepSeek：响应时间、缓存命中率、推理模式使用率
  - Gemini：多模态处理时间、安全过滤延迟、Live API连接质量
  - SiliconFlow：批处理效率、模型切换频率、余额变化趋势
- **成本监控**：Token使用量、API调用费用、性价比分析

### 7.2 错误监控
- **全局错误捕获**：JavaScript运行时错误
- **Promise错误捕获**：未处理的Promise拒绝
- **网络错误监控**：API请求失败统计
- **用户行为追踪**：操作路径和错误上下文
- **AI服务特定错误监控**：
  - DeepSeek：推理模式失败、KV缓存错误、兼容性问题
  - Gemini：安全过滤拦截、多模态处理失败、OAuth认证错误
  - SiliconFlow：余额不足、模型不可用、批处理失败
- **服务降级监控**：服务商间的切换频率和成功率

### 7.3 日志管理
- **分级日志**：DEBUG、INFO、WARN、ERROR
- **本地日志**：开发环境详细日志
- **用户日志**：生产环境必要日志
- **日志导出**：支持日志数据导出用于问题排查

## 8. 扩展性设计

### 8.1 插件架构
- **插件接口**：标准化的插件开发接口
- **热插拔**：支持运行时加载/卸载插件
- **依赖管理**：插件间依赖关系管理
- **沙箱隔离**：插件运行环境隔离

### 8.2 主题系统
- **可换肤**：支持多套视觉主题
- **自定义主题**：用户可创建自定义主题
- **响应式主题**：根据系统偏好自动切换
- **动态加载**：主题资源按需加载

### 8.3 国际化支持
- **多语言**：支持多种界面语言
- **本地化**：数字、日期格式本地化
- **RTL支持**：从右到左语言支持
- **动态切换**：运行时语言切换

## 9. 开发和部署流程

### 9.1 开发流程

#### 9.1.1 UI先行开发策略
采用**UI界面优先**的开发模式，每完成一个核心模块立即进行界面测试验证：

```
开发流程：UI集成 → 模块开发 → 界面测试 → 功能验证
          ↓         ↓         ↓         ↓
        视觉界面   业务逻辑   交互验证   完整功能
```

**核心原则**：
- **可视化验证**：每个模块完成后能在UI界面直接测试
- **早期反馈**：问题在开发阶段就能通过界面发现
- **渐进集成**：模块功能逐步填充到已有UI框架中
- **持续测试**：开发过程中持续验证用户体验

#### 9.1.2 模块化开发顺序
1. **Phase 1**：UI界面 + 基础架构并行开发
2. **Phase 2**：核心功能模块（状态管理、AI服务）
3. **Phase 3**：配置系统和扩展功能
4. **Phase 4**：优化、测试和部署

#### 9.1.3 代码质量控制
- **Git Flow**：功能分支开发模式
- **代码规范**：ESLint + Prettier代码格式化
- **类型检查**：TypeScript类型检查
- **单元测试**：Jest + React Testing Library
- **E2E测试**：Playwright端到端测试

### 9.2 CI/CD流程
- **自动构建**：代码提交触发构建
- **自动测试**：构建过程中运行全部测试
- **自动部署**：测试通过后自动部署到CDN
- **回滚机制**：部署失败时自动回滚

### 9.3 版本管理
- **语义化版本**：遵循SemVer版本规范
- **变更日志**：自动生成版本变更记录
- **向后兼容**：数据格式和API的兼容性保证
- **渐进升级**：用户数据的平滑迁移

---

**文档版本**: v2.0  
**创建时间**: 2025-09-25  
**更新时间**: 2025-09-25  
**维护人员**: 系统架构师  
**更新内容**: 支持三个主要AI服务商(DeepSeek/Gemini/SiliconFlow)的架构优化