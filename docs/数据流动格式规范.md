# 数据流动格式规范

## 1. 用户 → 网站

### 1.1 文本输入
```javascript
{
  type: "user_input",
  content: "我想向北走"
}
```

### 1.2 点击选项
```javascript
{
  type: "option_click", 
  option_id: "A"  // 对应选项的id（A/B/C）
}
```

### 1.3 配置操作
```javascript
// AI配置
{
  type: "ai_config",
  data: {
    api_url: "https://api.openai.com/v1/chat/completions",
    api_key: "sk-xxx...",
    model: "gpt-4",
    temperature: 0.7,
    timeout: 30
  }
}

// 状态栏配置（必填）
{
  type: "status_config",
  data: {
    fields: [
      {name: "health", display: "生命值", type: "progress", max: 100, initial: 100},
      {name: "mana", display: "魔力", type: "progress", max: 50, initial: 50},
      {name: "experience", display: "经验", type: "number", initial: 0},
      {name: "gold", display: "金币", type: "number", initial: 0}
    ]
  }
}

// 扩展卡片配置
{
  type: "extension_config",
  data: {
    name: "好感度",
    position: "left",
    dataType: "object",
    displayFormat: "key-value",
    description: "显示与各个NPC的关系状态"
  }
}
```

## 2. 网站 → AI

### 2.1 完整的Prompt格式（纯文本）
```text
=== 游戏世界观 ===
你是一个中世纪奇幻世界的游戏主持人。在这个世界中...
（用户设定的世界观和规则）

=== 角色背景 ===
玩家扮演一名年轻的冒险者...
（角色设定）

=== 历史回合摘要 ===
第1回合：玩家从村庄出发，向森林进发
第2回合：遇到了友好的精灵，获得了指引
第3回合：...
（最近5-10回合的简要总结）

=== 当前角色状态 ===
生命值: 75/100
魔力: 30/50
经验: 260
金币: 50
（注：具体字段由用户状态栏配置决定，进度条类型需包含当前值和最大值）

=== 当前扩展信息 ===
背包: 面包 x2, 水瓶 x1, 短剑 x1
任务: 探索森林 (进行中 3/5)
好感度: 森林精灵 (友好)

=== 玩家当前操作 ===
我想向北走

=== 输出要求 ===
请必须严格按照以下JSON格式输出，内容使用自然语言描述：

```json
{
  "scene": "场景的详细自然语言描述，包含环境、氛围、视觉细节等",
  "narration": "旁白内容——以第三人称视角叙述当前回合的情况变化", 
  "options": [
    {"id": "A", "text": "选项A的具体行动描述"},
    {"id": "B", "text": "选项B的具体行动描述"},
    {"id": "C", "text": "选项C的具体行动描述"}
  ],
  "status": {
    // 具体字段由用户状态栏配置决定，以下为示例：
    "health": {"value": 数值, "max": 数值}, // 进度条类型
    "mana": {"value": 数值, "max": 数值},    // 进度条类型
    "experience": 数值,  // 数值类型（无上限）
    "gold": 数值        // 数值类型（无上限）
  },
  "custom": {
    "背包": ["物品1", "物品2"],
    "任务": [
      {
        "name": "任务名称",
        "progress": "进度描述",
        "status": "状态"
      }
    ],
    "好感度": {
      "NPC名称1": "关系状态1",
      "NPC名称2": "关系状态2"
    }
  }
}
```

关键要求：
1. JSON必须完整且格式正确，不能有多余的逗号
2. 内容使用生动的自然语言，但结构要固定
3. options必须提供3个，id固定为A、B、C，不可省略或清加
4. status字段必须与用户配置的状态栏字段完全一致，进度条类型使用{value,max}对象格式
5. custom中的key优先使用系统配置的扩展卡片名称，未配置的key放入custom._extra中
6. 所有数值必须是数字类型，不要用字符串
7. 请勿使用"event"字段，必须使用"narration"
8. 开始游戏前必须配置好世界观和状态栏，两者为必填项
```

### 2.2 API请求参数（按服务商分类）

#### DeepSeek API请求格式
```javascript
{
  model: "deepseek-chat", // 或 "deepseek-reasoner" 用于推理任务
  messages: [
    {
      role: "user", 
      content: "（上述完整prompt）"
    }
  ],
  temperature: 0.7,
  max_tokens: 2000,
  stream: false,
  timeout: 30000  // 30秒超时
}

// 推理模式请求（支持reasoning_content）
{
  model: "deepseek-reasoner",
  messages: [{ role: "user", content: "用户输入" }],
  stream: true // 推荐流式获取推理过程
}
```

#### Google Gemini API请求格式
```javascript
{
  contents: [
    {
      parts: [
        {
          text: "（上述完整prompt）"
        }
      ]
    }
  ],
  generationConfig: {
    temperature: 0.7,
    maxOutputTokens: 2000,
    topK: 40,
    topP: 0.95
  },
  safetySettings: [
    {
      category: "HARM_CATEGORY_HARASSMENT",
      threshold: "BLOCK_MEDIUM_AND_ABOVE"
    }
  ]
}

// 请求头
{
  "x-goog-api-key": "your-api-key",
  "Content-Type": "application/json"
}
```

#### SiliconFlow API请求格式
```javascript
{
  model: "Qwen/Qwen2.5-7B-Instruct", // 或其他支持的模型
  messages: [
    {
      role: "user",
      content: "（上述完整prompt）"
    }
  ],
  temperature: 0.7,
  max_tokens: 2000,
  stream: false,
  timeout: 30000
}

// 请求头
{
  "Authorization": "Bearer your-api-key",
  "Content-Type": "application/json"
}
```

## 3. AI → 网站

### 3.1 标准JSON响应格式
```json
{
  "scene": "你踏上通往北方的小径，两旁是高大的橡树，树叶在微风中沙沙作响。阳光透过枝叶的缝隙洒下斑驳的光影，前方的小径蜿蜒向上，消失在茂密的绿色中。空气中弥漫着青草和野花的清香。",
  "narration": "你沿着小径向北走了一段距离，感觉精神状态良好，但体力消耗了一些。",
  "options": [
    {"id": "A", "text": "加快脚步继续前进"},
    {"id": "B", "text": "放慢速度，仔细观察周围"},
    {"id": "C", "text": "找个地方休息片刻"}
  ],
  "status": {
    "health": {"value": 72, "max": 100},
    "mana": {"value": 30, "max": 50},
    "experience": 265,
    "gold": 50
    // 注意：字段名和数量必须与用户配置一致
  },
  "custom": {
    "背包": ["面包 x2", "水瓶 x1", "短剑 x1", "野花 x1"],
    "任务": [
      {
        "name": "探索森林",
        "progress": "4/5",
        "status": "进行中",
        "description": "继续深入探索森林的秘密"
      }
    ],
    "好感度": {
      "森林精灵": "友好",
      "村长": "中性"
    },
    "技能": {
      "徒步": {"level": 2, "exp": "45/100"},
      "观察": {"level": 1, "exp": "15/50"}
    }
  }
}
```

### 3.2 可能的响应格式变体
```text
// 情况1：AI用markdown包裹JSON
```json
{实际JSON内容}
```

// 情况2：AI在JSON前后加了说明文字
这是游戏的下一回合：
{实际JSON内容}
希望你喜欢这个场景！

// 情况4：DeepSeek推理模式特殊格式
Let me think about this...

<reasoning>
这里是推理过程的内容...
</reasoning>

{实际JSON内容}

// 情况5：Gemini安全过滤响应
{
  "candidates": []
  "promptFeedback": {
    "blockReason": "SAFETY",
    "safetyRatings": [...]
  }
}

// 情况6：SiliconFlow批处理响应
{
  "id": "batch_abc123",
  "object": "batch",
  "status": "completed",
  "results": [
    {实际JSON内容}
  ]
}

// 情况3：AI返回格式有小错误
{
  "scene": "...",
  "narration": "...",  // 多了逗号
}
```

## 4. 网站内部处理

### 4.1 AI响应解析处理
```javascript
function parseAIResponse(rawText, userStatusConfig) {
  let result = {
    success: false,
    data: null,
    error: null,
    retry_needed: false
  };
  
  try {
    // 步骤1：提取JSON
    let jsonText = extractJSON(rawText);
    
    // 步骤2：尝试解析
    let parsed = JSON.parse(jsonText);
    
    // 步骤3：校验必需字段
    parsed = validateAndFix(parsed, userStatusConfig);
    
    // 步骤4：填充默认值
    parsed = fillDefaults(parsed, userStatusConfig);
    
    result.success = true;
    result.data = parsed;
    
  } catch (error) {
    result.error = error.message;
    result.retry_needed = shouldRetry(error);
  }
  
  return result;
}

// 提取JSON的策略
function extractJSON(text) {
  // 策略1：提取markdown包裹的JSON
  let match = text.match(/```json\s*([\s\S]*?)\s*```/);
  if (match) return match[1];
  
  // 策略2：提取第一个完整的JSON对象
  let start = text.indexOf('{');
  if (start === -1) throw new Error('未找到JSON对象');
  
  let braceCount = 0;
  let end = start;
  for (let i = start; i < text.length; i++) {
    if (text[i] === '{') braceCount++;
    if (text[i] === '}') braceCount--;
    if (braceCount === 0) {
      end = i + 1;
      break;
    }
  }
  
  return text.substring(start, end);
}

// 轻修补策略
function validateAndFix(obj) {
  // 修复常见字段名问题
  const fieldMapping = {
    'event': 'narration',
    '事件说明': 'narration', 
    '事件': 'narration',
    '情况说明': 'narration'
  };
  
  Object.keys(fieldMapping).forEach(oldField => {
    if (obj[oldField] && !obj[fieldMapping[oldField]]) {
      obj[fieldMapping[oldField]] = obj[oldField];
      delete obj[oldField];
    }
  });
  
  // 修复选项格式
  if (obj.options && Array.isArray(obj.options)) {
    obj.options = obj.options.map((option, index) => {
      if (typeof option === 'string') {
        return {
          id: String.fromCharCode(65 + index), // A, B, C
          text: option
        };
      }
      return option;
    });
  }
  
  return obj;
}

// 填充默认值
function fillDefaults(obj, userStatusConfig) {
  return {
    scene: obj.scene || "场景描述缺失",
    narration: obj.narration || "旁白内容缺失", 
    options: obj.options || [
      {"id": "A", "text": "继续"}, 
      {"id": "B", "text": "等待"},
      {"id": "C", "text": "返回"}
    ],
    status: obj.status || generateDefaultStatus(userStatusConfig),
    custom: obj.custom || {}
  };
}

// 根据用户配置生成默认状态值
function generateDefaultStatus(statusConfig) {
  const defaultStatus = {};
  statusConfig.fields.forEach(field => {
    if (field.type === 'progress') {
      defaultStatus[field.name] = {
        value: field.initial || 0,
        max: field.max || 100
      };
    } else {
      defaultStatus[field.name] = field.initial || 0;
    }
  });
  return defaultStatus;
}
```

### 4.2 内部存储格式
```javascript
{
  round_id: "round_001",
  timestamp: "2024-01-01T10:00:00Z",
  user_input: {
    type: "user_input",
    content: "我想向北走"
  },
  ai_response: {
    scene: "你踏上通往北方的小径...",
    narration: "你沿着小径向北走了一段距离...", 
    options: [
      {"id": "A", "text": "加快脚步继续前进"},
      {"id": "B", "text": "放慢速度，仔细观察周围"},
      {"id": "C", "text": "找个地方休息片刻"}
    ],
    status: {health: 72, experience: 265, money: 50},
    custom: {
      "背包": ["面包 x2", "水瓶 x1", "短剑 x1", "野花 x1"],
      "任务": [...],
      "好感度": {...}
    }
  },
  parse_status: "success", // "success" | "error" | "retry" | "fixed"
  error_info: null // 如果有错误，记录错误信息
}
```

## 5. 本地存储格式

### 5.1 导出文件格式
```javascript
{
  format_version: "1.0",
  export_time: "2024-01-01T10:00:00Z",
  game_config: {
    world_background: "用户设定的世界观...",
    character_background: "角色背景...",
    extension_cards: [
      {
        name: "背包",
        position: "left",
        dataType: "array",
        displayFormat: "list"
      },
      {
        name: "好感度", 
        position: "right",
        dataType: "object",
        displayFormat: "key-value"
      }
    ]
    // 注意：不包含API密钥
  },
  game_history: [
    // 所有回合的完整数据...
  ],
  statistics: {
    total_rounds: 15,
    total_tokens_used: 12500,
    game_duration: "2h 30m"
  }
}
```

## 6. 错误处理流程

### 6.1 请求错误（按AI服务商分类处理）

#### DeepSeek 错误处理
```javascript
{
  error_type: "deepseek_request_failed",
  error_code: "invalid_api_key" | "quota_exceeded" | "model_not_found" | "reasoning_failed",
  error_message: "具体错误信息",
  service_provider: "deepseek",
  retry_count: 1,
  max_retries: 2,
  suggested_action: "检查密钥" | "切换模型" | "稍后重试",
  
  // DeepSeek特定信息
  cache_hit_rate: 0.75,        // KV缓存命中率
  reasoning_tokens: 1200,      // 推理模式使用的tokens
  compatibility_mode: "openai" // 当前使用的兼容模式
}
```

#### Gemini 错误处理
```javascript
{
  error_type: "gemini_request_failed",
  error_code: "safety_filtered" | "invalid_api_key" | "quota_exceeded" | "multimodal_error",
  error_message: "具体错误信息",
  service_provider: "gemini",
  retry_count: 1,
  max_retries: 3,
  suggested_action: "调整安全设置" | "检查API密钥" | "稍后重试",
  
  // Gemini特定信息
  safety_ratings: [            // 安全评级信息
    {
      category: "HARM_CATEGORY_HARASSMENT",
      probability: "MEDIUM"
    }
  ],
  blocked_reason: "SAFETY",    // 被拦截原因
  candidate_count: 0           // 候选回答数量
}
```

#### SiliconFlow 错误处理
```javascript
{
  error_type: "siliconflow_request_failed",
  error_code: "balance_insufficient" | "model_unavailable" | "batch_failed" | "invalid_api_key",
  error_message: "具体错误信息",
  service_provider: "siliconflow",
  retry_count: 1,
  max_retries: 2,
  suggested_action: "充值余额" | "切换模型" | "检查配置",
  
  // SiliconFlow特定信息
  current_balance: "12.50",    // 当前余额
  available_models: [          // 可用模型列表
    "Qwen/Qwen2.5-7B-Instruct",
    "deepseek-ai/DeepSeek-V2.5"
  ],
  service_type: "chat",        // 当前服务类型
  batch_id: "batch_123"        // 批处理ID（如果适用）
}
```

### 6.2 解析错误（多种修复策略Ｉ

#### 通用解析错误
```javascript
{
  error_type: "parse_failed", 
  error_code: "invalid_json" | "missing_field" | "wrong_format" | "field_mismatch",
  raw_response: "AI的原始回复",
  attempted_fixes: ["字段映射", "格式修复", "默认值填充"],
  fixed_data: "修复后的数据（如果修复成功）",
  retry_needed: true,
  model_stability: "high" | "medium" | "low", // 该模型对JSON输出的稳定性评估
  service_provider: "deepseek" | "gemini" | "siliconflow"
}
```

#### DeepSeek 解析特殊处理
```javascript
{
  // 基本解析错误信息...
  
  deepseek_specific: {
    reasoning_content_available: true,  // 是否有推理内容
    reasoning_parsing_success: false,   // 推理内容解析是否成功
    cache_usage: {
      hit_tokens: 150,                  // 缓存命中的tokens
      miss_tokens: 850                  // 缓存未命中的tokens
    },
    fallback_to_standard: true          // 是否降级到标准模式
  }
}
```

#### Gemini 解析特殊处理
```javascript
{
  // 基本解析错误信息...
  
  gemini_specific: {
    finish_reason: "STOP" | "MAX_TOKENS" | "SAFETY" | "RECITATION",
    safety_filtered: false,             // 是否被安全过滤器拦截
    citation_metadata: [],              // 引用元数据
    usage_metadata: {
      prompt_token_count: 100,
      candidates_token_count: 200,
      total_token_count: 300
    },
    multimodal_used: false              // 是否使用了多模态输入
  }
}
```

#### SiliconFlow 解析特殊处理
```javascript
{
  // 基本解析错误信息...
  
  siliconflow_specific: {
    model_used: "Qwen/Qwen2.5-7B-Instruct", // 实际使用的模型
    model_switched: false,              // 是否自动切换了模型
    batch_processing: false,            // 是否使用批处理
    service_type: "chat",               // 服务类型
    cost_estimate: "0.002",             // 预估成本（元）
    alternative_models: [               // 可替代模型
      "deepseek-ai/DeepSeek-V2.5",
      "01-ai/Yi-1.5-34B-Chat"
    ]
  }
}
```

---

## 总结

**数据流向**：用户输入 → 网站组装prompt → AI返回JSON → 网站解析渲染 → 本地存储

**关键特点**：
- 用户交互简单化（简单对象）
- AI输入结构化（自然语言prompt + 严格JSON要求）
- AI输出标准化（JSON结构 + 自然语言内容）
- 容错机制完善（字段映射 + 格式修复 + 重试机制）
- 多模型适配（针对不同AI服务商的差异化处理）
- 存储格式统一（标准JSON便于导入导出）

**技术约束和服务商适配**：

#### 通用约束
- 必填项：世界观设定和状态栏配置为开始游戏的必要条件
- 选项数量：严格限制3个（A/B/C），不可变动
- 状态字段：必须与用户配置的状态栏字段完全一致
- 字段映射：系统自动处理event→narration等常见字段名变化
- 扩展卡片：custom字段优先使用已配置的卡片名称
- 数据类型：所有数值字段必须是number类型

#### DeepSeek 特定适配
- **推理模式支持**: 自动检测和解析reasoning_content字段
- **KV缓存优化**: 自动跟踪缓存命中率以优化成本
- **兼容模式**: 支持OpenAI和Anthropic API格式兼容
- **Token计算**: 使用官方tokenizer进行准确计算

#### Gemini 特定适配  
- **安全过滤器**: 自动处理安全过滤响应，提供降级方案
- **多模态支持**: 支持文本+图像输入（未来扩展）
- **用户反馈**: 自动处理promptFeedback字段
- **Token统计**: 支持按模态分类的token使用统计

#### SiliconFlow 特定适配
- **模型自适应**: 根据可用性自动切换模型
- **批处理支持**: 对大量请求自动启用批处理模式
- **余额监控**: 实时监控余额，余额不足时提醒
- **多服务支持**: 支持聊天、嵌入、语音等多种服务类型

#### 灵活性保证
- 支持不同世界观的不同状态字段组合
- 支持服务商间的动态切换和降级
- 支持流式和非流式响应处理
- 自动适配不同模型的参数范围和特性